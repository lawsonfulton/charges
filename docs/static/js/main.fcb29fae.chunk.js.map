{"version":3,"sources":["ChargeViewer.ts","Grid.ts","SpatialHash.ts","ChargeSystem.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["ChargeViewer","sys","two","scale","showDebug","partSprites","this","drawSpatialHash","Array","maxParts","i","makeNegCharge","update","origin","spatial","spacing","cellSize","cols","grid","nCols","rows","nRows","drawLine","sx","sy","ex","ey","makeLine","stroke","ci","start","vec2","clone","add","fromValues","toScreen","end","ri","circ","makeCircle","rad","fill","linewidth","rect","makeRectangle","noStroke","chargeGroup","makeGroup","collCirc","collisionRad","noFill","pWorld","ofst","width","height","pScreen","create","scaleAndAdd","nParts","pos","translation","set","Grid","TCreator","cells","length","row","col","offsets","res","r","c","inBounds","push","get","Cell","partIds","clear","pId","index","indexOf","splice","SpatialHash","particles","bounds","invCellSize","idToCell","min","ncol","Math","ceil","max","nrow","updateParticles","p","Error","getCells","cell","getCell","origCell","newCell","remove","gridP","sub","floor","pointToId","getCellAndNeighbors","point","sqrRad","ids","id","sqrDist","ChargeSystem","useSpatial","oldPos","charge","invMass","force","getBounds","buffer","spatialBounds","strength","f","normalize","qi","j","magnitude","offset","fi","fj","fGrav","idx","setParticle","dt","applyCoulombForces","p0","p1","a","p2","updatePosition","its","closeParts","getParticles","resolveCollision","pi","pj","mid","piNew","pjNew","glMatrix","setMatrixArrayType","SimulationApp","stageRef","useRef","twoRef","Two","fullscreen","autostart","simWidth","current","simHeight","systemRef","viewerRef","resize","updateBounds","attractParticles","step","useEffect","appendTo","bind","Events","unbind","title","className","type","onClick","MinusCircleOutlined","defaultValue","onChange","setCharge","PlusCircleOutlined","ref","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fcb29fae.chunk.js","sourcesContent":["import Two from \"twojs-ts\";\nimport { vec2 } from \"gl-matrix\";\n\nimport { ChargeSystem } from \"./ChargeSystem\";\n\nexport class ChargeViewer {\n  sys: ChargeSystem;\n  two: Two;\n  showDebug: boolean;\n  scale: number;\n  partSprites: Array<Two.Group>;\n\n  constructor(sys: ChargeSystem, two: Two, scale: number, showDebug: boolean) {\n    this.sys = sys;\n    this.two = two;\n    this.showDebug = showDebug;\n    this.scale = scale;\n\n    if (showDebug) {\n      this.drawSpatialHash();\n    }\n\n    this.partSprites = new Array<Two.Group>(sys.maxParts);\n    for (let i = 0; i < sys.maxParts; i++) {\n      this.partSprites[i] = this.makeNegCharge();\n    }\n\n    this.update();\n  }\n\n  drawSpatialHash() {\n    const origin = this.sys.spatial.origin;\n    const spacing = this.sys.spatial.cellSize;\n    const cols = this.sys.spatial.grid.nCols;\n    const rows = this.sys.spatial.grid.nRows;\n\n    const drawLine = (sx: number, sy: number, ex: number, ey: number) => {\n      let line = this.two.makeLine(sx, sy, ex, ey);\n      line.stroke = \"lightgrey\";\n    };\n\n    for (let ci = 0; ci < cols; ci++) {\n      const start = vec2.clone(origin);\n      vec2.add(start, start, vec2.fromValues(ci * spacing, 0));\n      const [sx, sy] = this.toScreen(start);\n\n      const end = vec2.clone(start);\n      vec2.add(end, end, vec2.fromValues(0, rows * spacing));\n      const [ex, ey] = this.toScreen(end);\n\n      drawLine(sx, sy, ex, ey);\n    }\n\n    for (let ri = 0; ri < rows; ri++) {\n      const start = vec2.clone(origin);\n      vec2.add(start, start, vec2.fromValues(0, ri * spacing));\n      const [sx, sy] = this.toScreen(start);\n\n      const end = vec2.clone(start);\n      vec2.add(end, end, vec2.fromValues(cols * spacing, 0));\n      const [ex, ey] = this.toScreen(end);\n\n      drawLine(sx, sy, ex, ey);\n    }\n  }\n\n  makeNegCharge() {\n    let circ = this.two.makeCircle(0, 0, this.sys.rad);\n    circ.fill = \"purple\";\n    circ.linewidth = 0.1;\n    // circ.noStroke();\n\n    let rect = this.two.makeRectangle(\n      0,\n      0,\n      1.2 * this.sys.rad,\n      0.3 * this.sys.rad\n    );\n    rect.fill = \"black\";\n    rect.noStroke();\n\n    let chargeGroup = this.two.makeGroup([circ]);\n\n    if (this.showDebug) {\n      let collCirc = this.two.makeCircle(0, 0, this.sys.collisionRad);\n      collCirc.noFill();\n      collCirc.linewidth = 0.1;\n      collCirc.stroke = \"lightgrey\";\n      chargeGroup.add(collCirc);\n    }\n\n    return chargeGroup;\n  }\n\n  toScreen(pWorld: vec2): vec2 {\n    const ofst = vec2.fromValues(this.two.width / 2.0, this.two.height / 2.0);\n    const pScreen = vec2.create();\n    vec2.scaleAndAdd(pScreen, ofst, pWorld, this.scale);\n    return pScreen;\n  }\n\n  update() {\n    for (let i = 0; i < this.sys.nParts; i++) {\n      const pScreen = this.toScreen(this.sys.pos[i]);\n      this.partSprites[i].translation.set(pScreen[0], pScreen[1]);\n      this.partSprites[i].scale = this.scale;\n    }\n  }\n}\n","export class Grid<T> {\n  nRows: number;\n  nCols: number;\n  cells: Array<T>; // Row-major\n\n  constructor(TCreator: { new (): T }, nRows: number, nCols: number) {\n    this.nRows = nRows;\n    this.nCols = nCols;\n    this.cells = new Array<T>(nRows * nCols);\n    for (let i = 0; i < this.cells.length; i++) {\n      this.cells[i] = new TCreator();\n    }\n  }\n\n  get(row: number, col: number): T {\n    return this.cells[col + row * this.nCols];\n  }\n\n  getCellAndNeighbors(row: number, col: number): Array<T> {\n    const offsets = [\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 1],\n      [-1, 1],\n      [-1, 0],\n      [-1, -1],\n      [0, -1],\n      [1, -1],\n    ];\n    let res = new Array<T>(offsets.length);\n    res.length = 0;\n    for (const ofst of offsets) {\n      const r = row + ofst[0];\n      const c = col + ofst[1];\n\n      if (this.inBounds(r, c)) {\n        res.push(this.get(r, c));\n      }\n    }\n\n    return res;\n  }\n\n  inBounds(row: number, col: number) {\n    return row >= 0 && row < this.nRows && col >= 0 && col < this.nCols;\n  }\n\n  getCells(): Array<T> {\n    return this.cells;\n  }\n}\n","import { BBox } from \"./BBox\";\nimport { Grid } from \"./Grid\";\nimport { vec2 } from \"gl-matrix\";\n\nclass Cell {\n  partIds: Array<number>; // Stores index in the particles Array\n\n  constructor() {\n    this.partIds = new Array<number>(10); // preallocate for 10?\n    this.clear();\n  }\n\n  add(pId: number) {\n    this.partIds.push(pId);\n  }\n\n  remove(pId: number) {\n    const index = this.partIds.indexOf(pId);\n    this.partIds.splice(index, 1);\n  }\n\n  ids(): Array<number> {\n    return this.partIds;\n  }\n\n  clear() {\n    this.partIds.length = 0;\n  }\n}\n\nexport class SpatialHash {\n  readonly cellSize: number;\n  readonly invCellSize: number;\n  readonly bounds: BBox;\n  readonly origin: vec2; // origin at bounds.min\n  grid: Grid<Cell>;\n  idToCell: Array<Cell>;\n\n  constructor(particles: Array<vec2>, cellSize: number, bounds: BBox) {\n    this.cellSize = cellSize;\n    this.invCellSize = 1.0 / cellSize;\n    this.bounds = bounds;\n    this.origin = bounds.min;\n\n    // Set up grid\n    const ncol = Math.ceil((bounds.max[0] - bounds.min[0]) / cellSize);\n    const nrow = Math.ceil((bounds.max[0] - bounds.min[0]) / cellSize);\n    this.grid = new Grid<Cell>(Cell, nrow, ncol);\n\n    // Set up reverse index\n    this.idToCell = new Array<Cell>(particles.length);\n\n    // Add the particles\n    this.updateParticles(particles);\n  }\n\n  private checkBounds(pos: Array<vec2>) {\n    for (const p of pos) {\n      if (\n        p[0] > this.bounds.max[0] ||\n        p[1] > this.bounds.max[1] ||\n        p[0] < this.bounds.min[0] ||\n        p[1] < this.bounds.min[1]\n      ) {\n        throw new Error(\"Attempting to add particle outside of bounds\");\n      }\n    }\n  }\n\n  updateParticles(particles: Array<vec2>) {\n    // this.checkBounds(particles); // For debugging only\n    for (let cell of this.grid.getCells()) {\n      cell.clear();\n    }\n\n    for (let i = 0; i < particles.length; i++) {\n      const p = particles[i];\n      let cell = this.getCell(p);\n      cell.add(i);\n      this.idToCell[i] = cell;\n    }\n  }\n\n  // Update the position of an existing particle\n  setParticle(pId: number, pos: vec2) {\n    // this.checkBounds([pos]); // For debugging only\n    let origCell = this.idToCell[pId];\n    let newCell = this.getCell(pos);\n    if (newCell !== origCell) {\n      origCell.remove(pId);\n      newCell.add(pId);\n      this.idToCell[pId] = newCell;\n    }\n  }\n\n  pointToId(p: vec2): [number, number] {\n    let gridP = vec2.create(); // gridP = floor((p - origin) / cellSize\n    vec2.sub(gridP, p, this.origin);\n    vec2.scale(gridP, gridP, this.invCellSize);\n    vec2.floor(gridP, gridP);\n\n    return [gridP[0], gridP[1]];\n  }\n\n  getCell(p: vec2): Cell {\n    return this.grid.get(...this.pointToId(p));\n  }\n\n  getCellAndNeighbors(p: vec2): Array<Cell> {\n    return this.grid.getCellAndNeighbors(...this.pointToId(p));\n  }\n\n  getParticles(\n    particles: Array<vec2>,\n    point: vec2,\n    sqrRad: number\n  ): Array<number> {\n    let res = new Array<number>();\n\n    const cells = this.getCellAndNeighbors(point);\n    for (const cell of cells) {\n      for (const id of cell.ids()) {\n        const p = particles[id];\n        if (vec2.sqrDist(p, point) < sqrRad) {\n          res.push(id);\n        }\n      }\n    }\n\n    return res;\n  }\n}\n","import { SpatialHash } from \"./SpatialHash\";\nimport { BBox } from \"./BBox\";\n\nimport { vec2 } from \"gl-matrix\";\nimport { number } from \"mathjs\";\n\n// TODO\n// 1. Make Spatial Hash own the position array so they can't get out of sync\n\nexport class ChargeSystem {\n  useSpatial: boolean;\n  spatial: SpatialHash;\n\n  // State\n  pos: Array<vec2>;\n  oldPos: Array<vec2>;\n  charge: Array<number>;\n  invMass: Array<number>;\n\n  // Simulation params\n  nParts: number;\n  maxParts: number;\n  rad: number; // Constant for now\n  collisionRad: number;\n  bounds: BBox;\n\n  // Temporaries\n  force: Array<vec2>;\n\n  constructor(maxParts: number, width: number, height: number) {\n    this.nParts = maxParts; // Could be less than max\n    this.maxParts = maxParts;\n\n    this.rad = 1;\n    this.collisionRad = this.rad * this.rad * 4; // * 3;\n\n    this.bounds = this.getBounds(width, height);\n\n    this.pos = new Array<vec2>(maxParts);\n    this.oldPos = new Array<vec2>(maxParts);\n    for (let i = 0; i < maxParts; i++) {\n      this.pos[i] = vec2.fromValues(\n        this.rad * 2 + this.bounds.min[0] + ((i / 10) >> 0) * 2,\n        (i % 10) * 2\n      ); // grid\n\n      // Copy current pos into old pos\n      this.oldPos[i] = vec2.clone(this.pos[i]);\n    }\n\n    this.charge = new Array<number>(maxParts);\n    this.charge.fill(-1.0);\n\n    this.invMass = new Array<number>(maxParts);\n    this.invMass.fill(1.0);\n\n    this.force = new Array<vec2>(maxParts);\n    for (let i = 0; i < this.nParts; i++) {\n      this.force[i] = vec2.fromValues(0.0, 0.0);\n    }\n\n    // spatial bounds need to be a bit bigger to account for overshoot\n    this.useSpatial = true;\n    const cellSize = this.rad * 4;\n    const buffer = this.rad * 8 * 2;\n    const spatialBounds = {\n      max: vec2.fromValues(width / 2 + buffer, height / 2 + buffer),\n      min: vec2.fromValues(-(width / 2) - buffer, -(height / 2) - buffer),\n    };\n    this.spatial = new SpatialHash(this.pos, cellSize, spatialBounds);\n  }\n\n  getBounds(width: number, height: number): BBox {\n    return {\n      max: vec2.fromValues(width / 2 - this.rad, height / 2 - this.rad),\n      min: vec2.fromValues(-(width / 2 - this.rad), -(height / 2 - this.rad)),\n    };\n  }\n\n  updateBounds(width: number, height: number) {\n    this.bounds = this.getBounds(width, height);\n  }\n\n  setCharge(charge: number) {\n    this.charge.fill(charge);\n  }\n\n  attractParticles(point: vec2, strength: number) {\n    for (let i = 0; i < this.nParts; i++) {\n      const f = vec2.create();\n      vec2.sub(f, point, this.pos[i]);\n      vec2.normalize(f, f);\n      vec2.scale(f, f, strength);\n\n      vec2.add(this.force[i], this.force[i], f);\n    }\n  }\n\n  applyCoulombForces() {\n    // Need to use fast multipole method for this part\n    // for (let i = 0; i < this.nParts; i++) {\n    //   const closeParts = this.spatial.getParticles(\n    //     this.pos,\n    //     this.pos[i],\n    //     100,\n    //   );\n\n    //   const qi = this.charge[i];\n    //   for (const j of closeParts) {\n      //     if (j !== i) {\n        //       const qj = this.charge[j];\n        \n        //       const magnitude =\n        //         ((qi * qj) / vec2.sqrDist(this.pos[i], this.pos[j])) * 50;\n        \n        //       const offset = vec2.create();\n        //       vec2.sub(offset, this.pos[j], this.pos[i]); // vec from pi to pj\n        //       vec2.normalize(offset, offset);\n        \n        //       const fi = vec2.create(); // force acting on pi\n        //       vec2.scale(fi, offset, -magnitude);\n        \n        //       const fj = vec2.create(); // force acting on pi\n        //       vec2.scale(fj, offset, magnitude);\n        \n        //       vec2.add(this.force[i], this.force[i], fi);\n        //       vec2.add(this.force[j], this.force[j], fj);\n        //     }\n        //   }\n        // }\n        \n    for (let i = 0; i < this.nParts; i++) {\n      const qi = this.charge[i];\n\n      for (let j = i + 1; j < this.nParts; j++) {\n        const qj = this.charge[j];\n\n        const magnitude =\n          ((qi * qj) / vec2.sqrDist(this.pos[i], this.pos[j])) * 50;\n\n        const offset = vec2.create();\n        vec2.sub(offset, this.pos[j], this.pos[i]); // vec from pi to pj\n        vec2.normalize(offset, offset);\n\n        const fi = vec2.create(); // force acting on pi\n        vec2.scale(fi, offset, -magnitude);\n\n        const fj = vec2.create(); // force acting on pi\n        vec2.scale(fj, offset, magnitude);\n\n        vec2.add(this.force[i], this.force[i], fi);\n        vec2.add(this.force[j], this.force[j], fj);\n      }\n    }\n  }\n\n  applyGravity() {\n    const fGrav = vec2.fromValues(0.0, 9.8);\n    for (let i = 0; i < this.nParts; i++) {\n      vec2.add(this.force[i], this.force[i], fGrav);\n    }\n  }\n\n  private updatePosition(idx: number, pos: vec2) {\n    this.pos[idx] = pos;\n    // TODO Maybe I should just fully abstract the position array\n    if (this.useSpatial) {\n      this.spatial.setParticle(idx, pos);\n    }\n  }\n\n  step(dt: number) {\n    this.applyCoulombForces();\n    // this.applyGravity();\n\n    // a = F/m\n    // Could store result back in F to optimize\n    for (let i = 0; i < this.nParts; i++) {\n      const p0 = this.oldPos[i];\n      const p1 = this.pos[i];\n\n      let a = vec2.create();\n      vec2.scale(a, this.force[i], this.invMass[i]);\n\n      let p2 = vec2.create();\n      vec2.scale(p2, p1, 2.0); // 2x_n\n      vec2.scaleAndAdd(p2, p2, p0, -1); // - x_n-1\n      vec2.scaleAndAdd(p2, p2, a, dt * dt); // + a_n * t^2\n\n      // Update\n      this.updatePosition(i, p2);\n      this.oldPos[i] = p1;\n    }\n\n    // collisions\n    // this.spatial.updateParticles(this.pos);\n    for (let its = 0; its < 2; its++) {\n      for (let i = 0; i < this.nParts; i++) {\n        // bounds\n        vec2.min(this.pos[i], this.pos[i], this.bounds.max);\n        vec2.max(this.pos[i], this.pos[i], this.bounds.min);\n\n        if (this.useSpatial) {\n          const closeParts = this.spatial.getParticles(\n            this.pos,\n            this.pos[i],\n            this.collisionRad\n          );\n\n          for (const j of closeParts) {\n            if (j !== i) {\n              this.resolveCollision(i, j);\n            }\n          }\n        } else {\n          for (let j = i + 1; j < this.nParts; j++) {\n            this.resolveCollision(i, j);\n          }\n        }\n      }\n    }\n\n    // reset forces\n    for (let i = 0; i < this.nParts; i++) {\n      this.force[i] = vec2.fromValues(0.0, 0.0);\n    }\n  }\n\n  resolveCollision(i: number, j: number) {\n    const pi = this.pos[i];\n    const pj = this.pos[j];\n\n    const sqrD = vec2.sqrDist(pi, pj);\n    // If they are overlapping (assuming constant radius)\n    if (sqrD < (this.rad * 2) ** 2) {\n      const mid = vec2.create();\n      vec2.add(mid, pi, pj);\n      vec2.scale(mid, mid, 0.5);\n\n      // normalized\n      const offset = vec2.create();\n      vec2.sub(offset, pi, mid); // vec from mid to pi\n      vec2.normalize(offset, offset); // normalized\n      vec2.scale(offset, offset, this.rad);\n\n      const piNew = vec2.create();\n      vec2.add(piNew, mid, offset);\n\n      const pjNew = vec2.create();\n      vec2.scaleAndAdd(pjNew, mid, offset, -1.0);\n\n      // update\n      this.updatePosition(i, piNew);\n      this.updatePosition(j, pjNew);\n    }\n  }\n}\n","import React, { useEffect, useRef } from \"react\";\nimport { Button, Card, Slider } from \"antd\";\nimport { MinusCircleOutlined, PlusCircleOutlined } from \"@ant-design/icons\";\nimport './App.css';\n\nimport { ChargeViewer } from \"./ChargeViewer\";\nimport { ChargeSystem } from \"./ChargeSystem\";\n\nimport Two from \"twojs-ts\";\nimport Stats from \"stats.js\";\n\nimport { glMatrix, vec2 } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Array); // Faster than TypedArray\n\nconst SimulationApp = () => {\n  // Must use refs to manage simulation state independently from React\n  let stageRef = useRef() as React.MutableRefObject<HTMLInputElement>;\n  let twoRef = useRef(new Two({fullscreen: true, autostart: true }));\n\n  // Simulation uses particles of unit radius by default\n  // The scale constant determines how big the particles appear on screen\n  // Or, the ration between screen space and world space\n  const scale = 14;\n\n  // Set the bounds of the simulation to be the bounds of the screen scaled\n  // down to world space\n  const simWidth = twoRef.current.width / scale;\n  const simHeight = twoRef.current.height / scale;\n\n  const showDebug = false;\n  let systemRef = useRef(new ChargeSystem(100, simWidth, simHeight));\n  let viewerRef = useRef(\n    new ChargeViewer(systemRef.current, twoRef.current, scale, showDebug)\n  );\n    \n  // One time call to setup function\n  // which sets up callbacks and attaches the two.js stage\n  // to the dom.\n  useEffect(setup, []);\n  function setup() {\n    let two = twoRef.current;\n    two.appendTo(stageRef.current);\n    two.bind(Two.Events.update, update);\n    two.bind(Two.Events.resize, resize);\n\n    return function () {\n      // Unmount handler\n      two.unbind(Two.Events.update, update);\n      two.unbind(Two.Events.resize, resize);\n    }; \n  }\n  \n  // Called when window is resized\n  function resize() {\n    const simWidth = twoRef.current.width / scale;\n    const simHeight = twoRef.current.height / scale;\n    systemRef.current.updateBounds(simWidth, simHeight);\n  }\n\n  // Called whenever animation frame is requested\n  function update() {\n    // stats.begin();\n\n    systemRef.current.attractParticles(vec2.fromValues(0.1, 0.1), 20); //20);\n    systemRef.current.step(0.05);\n    \n    viewerRef.current.update();\n    \n    // stats.end();\n  }\n\n  function click() {\n    systemRef.current.attractParticles(vec2.fromValues(0, 0), 200); //20);\n  }\n\n  function setCharge(charge:number) {\n    systemRef.current.setCharge(charge);\n  }\n\n  return (\n    <div>\n      <Card title=\"Parameters\" className=\"control-panel\">\n        <Button type=\"primary\" onClick={click}>\n          Test\n        </Button>\n        <div className=\"charge-slider\">\n          <MinusCircleOutlined />\n          <Slider defaultValue={-1.0} min={-2.0} max={2.0} step={0.01} onChange={setCharge}/>\n          <PlusCircleOutlined />\n        </div>\n      </Card>\n      <div>\n        <div className=\"stage\" ref={stageRef} />\n      </div>\n    </div>\n  );\n};\n\n\nconst App = () => {\n  return (\n    <div className=\"Charges\">\n      <header className=\"Charges-header\"></header>\n      <SimulationApp />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}